@page "/game"

@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.SignalR;
@using TicTacToeGame.Domain.Constants
@using TicTacToeGame.Domain.Enums
@using TicTacToeGame.Domain.Models
@using System.Security.Claims
@using TicTacToeGame.Domain.Repositories
@using TicTacToeGame.Services.GamesStatisticServices
@using TicTacToeGame.WebUI.Components.Account

@inject NavigationManager _navigationManager
@inject PlayerRepository _playerRepository
@inject GameRepository _gameRepository
@inject AuthenticationStateProvider _authenticationStateProvider
@inject GamesHistoryRepository _gamesHistoryRepository
@inject IGamesStatisticsService _gamesStatisticsService
@inject IdentityRedirectManager RedirectManager

@implements IDisposable
@rendermode InteractiveServer

<h1 style="text-align: center;">Tic Tac Toe Game</h1>
@if (opponentLeaves)
{
    <h3 style="text-align: center;">Player @livedPlayerName leaves game</h3>

}
<div style="display: flex; flex-direction: column; align-items: center;">
    @for (int row = TicTacToeRules.FIRST_ROW_OF_BOARD; row < TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS; row++)
    {
        <div>
            @for (int col = TicTacToeRules.FIRST_ROW_OF_BOARD; col < TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS; col++)
            {
                int index = row * 3 + col;
                <button style="width: 100px; height: 100px; font-size: 24px; text-align: center; vertical-align: middle; margin-bottom: 5px;"
                        @onclick="(async () => await MakeMove(index))" disabled="@IsButtonDisabled(index)">
                    @GetSquareValue(index)
                </button>
            }
        </div>
    }
</div>

<p>@GameStatus</p>

@code {
    // Board
    private BoardElements[] board = new BoardElements[TicTacToeRules.BOARD_SIZE];

    // For checking current move number
    private int counter;

    // Display who win
    // Are using in signalR
    private string GameStatus = "";
    private string gameId = "";
    // Current game
    private TicTacToeGame.Domain.Models.Game CurrentGame = new();
    Player currentPlayerHost;
    Player currentPlayerGuest;

    // SignalR
    private HubConnection hubConnection;

    private bool canDisplay = false;
    private bool opponentLeaves = false;

    private string livedPlayerName = "";

    protected override async Task OnInitializedAsync()
    {
        GameStatus = "Game in progress";

        await HandleGameForAuthenticatedUser();
        
        currentPlayerHost = _playerRepository.GetById(CurrentGame.PlayerHostId);
        currentPlayerGuest = _playerRepository.GetById(CurrentGame.PlayerGuestId);


        hubConnection = new HubConnectionBuilder()
            .WithUrl(_navigationManager.ToAbsoluteUri("/gameHub"))
            .Build();

        hubConnection.On<BoardElements[], PlayerType, Guid>("SendGameState", (receivedBoard, nextPlayerTurn, gameId) =>
        {
            InvokeAsync(() =>
            {
                board = receivedBoard;
                CurrentGame.CurrentTurn = nextPlayerTurn;
                StateHasChanged();
            });
        });
        hubConnection.On<GameState, string, Guid>("SendGameStatus", (receiveGameResult, receiveGameStatus, gameId) =>
        {
            InvokeAsync(() =>
            {
                CurrentGame.GameResult = receiveGameResult;
                GameStatus = receiveGameStatus;
                StateHasChanged();
            });
        });

        hubConnection.On<Guid>("SendGroupMessage", (gameId) =>
        {
            InvokeAsync(() =>
            {
                this.gameId = gameId.ToString();
                canDisplay = true;
                StateHasChanged();
            });
        });

        hubConnection.On<string>("UserDisconnected", (connectionId) =>
        {
            InvokeAsync(() =>
            {
                if (currentPlayerHost.GameConnectionId == connectionId
                    || currentPlayerGuest.GameConnectionId == connectionId)
                {
                    if (currentPlayerHost.GameConnectionId == connectionId)
                    {
                        livedPlayerName = currentPlayerHost.UserName;
                    }
                    else
                    {
                        livedPlayerName = currentPlayerGuest.UserName;
                    }
                    // - Firstly we should know if it this connectionId contains one of our players, host or guest
                    // - Then we should display message that opponent leaved the game only for the player that was opponent for
                    //   the player that leaved the game

                    opponentLeaves = true;
                    StateHasChanged();
                    // TODO: 
                    // - Add manipulation with game and players in DB
                    
                    CurrentGame.GameResult = GameState.Declined;
                    CurrentGame.Winner = PlayerType.None;

                    _gameRepository.UpdateEntity(CurrentGame);
                }
            });
        });

        await hubConnection.StartAsync();
        await hubConnection.SendAsync("JoinGame", CurrentGame.UniqueId);

        string currentClientConnectionId = hubConnection.ConnectionId;

        // maybe add valdiation if users is null
        _playerRepository.UpdatePlayerGameContextId(currentClientConnectionId, currentPlayerHost, currentPlayerGuest, user);
        // maybe make some method for updating another player because on one client updates only one player

        currentPlayerHost = _playerRepository.GetById(CurrentGame.PlayerHostId);
        currentPlayerGuest = _playerRepository.GetById(CurrentGame.PlayerGuestId);

    }
    public async Task HandleGameForAuthenticatedUser()
    {
        AuthenticationState authState = await _authenticationStateProvider.GetAuthenticationStateAsync();
        ClaimsPrincipal? user = authState.User;

        if (IsAuthenticatedUserWithGame(user, out var userId))
        {
            CurrentGame = _gameRepository.GetByUsersId(userId);
        }
        else
        {
            RedirectManager.RedirectTo("/");
        }
    }

    private bool IsAuthenticatedUserWithGame(ClaimsPrincipal? user, out string userId)
    {
        userId = string.Empty;

        if (user?.Identity?.IsAuthenticated == true)
        {
            userId = user.Claims.First().Value.ToString();
            return _gameRepository.GetByUsersId(userId) is not null;
        }

        return false;
    }
    private async Task MakeMove(int index)
    {
        if (board[index] == BoardElements.Empty && CurrentGame.GameResult == GameState.Starting)
        {
            // Check if it's the correct player's turn
            if (await IsCurrentPlayersTurn())
            {
                // Put X or O on cell
                PlaceMoveOnCell(index);

                // Only after 3 movements can a player win
                await CheckForWinnerAfterMoves();

                // Switch player turns
                await SentGameState();
            }
        }
    }
    private void PlaceMoveOnCell(int index)
    {
        board[index] = (CurrentGame.CurrentTurn == PlayerType.Host) ? BoardElements.X : BoardElements.O;
        counter++;
    }
    private async Task CheckForWinnerAfterMoves()
    {
        if (counter >= TicTacToeRules.MIN_COUNT_OF_MOVE_TO_WIN)
        {
            if (CheckForWinner())
            {
                await FinishGameAndPutInHistory();
            }
        }
    }
    private async Task<bool> IsCurrentPlayersTurn()
    {
        AuthenticationState authState = await _authenticationStateProvider.GetAuthenticationStateAsync();
        ClaimsPrincipal? user = authState.User;

        return (CurrentGame.CurrentTurn == PlayerType.Host && user.Claims.First().Subject.Name == currentPlayerHost.UserName) ||
        (CurrentGame.CurrentTurn == PlayerType.Guest && user.Claims.First().Subject.Name == currentPlayerGuest.UserName);

    }
    private async Task FinishGameAndPutInHistory()
    {
        CurrentGame.GameResult = GameState.Finished;

        GamesHistory hostGamesHistory = await _gamesStatisticsService.GetGamesHistoryByPlayerId(currentPlayerHost.Id);
        GamesHistory guestGamesHistory = await _gamesStatisticsService.GetGamesHistoryByPlayerId(currentPlayerGuest.Id);

        CurrentGame.GamesHistoryHostId = hostGamesHistory.Id;
        CurrentGame.GamesHistoryGuestId = guestGamesHistory.Id;

        CurrentGame.Winner = CurrentGame.CurrentTurn;

        _gameRepository.UpdateEntity(CurrentGame);

        await SendGameStatus();
    }

    private async Task SentGameState()
    {
        PlayerType nextPlayerTurn = (CurrentGame.CurrentTurn == PlayerType.Host) ? PlayerType.Guest : PlayerType.Host;
        await hubConnection.SendAsync("SendGameState", board, nextPlayerTurn, CurrentGame.UniqueId);
    }

    private async Task SendGameStatus()
    {
        await hubConnection.SendAsync("SendGameStatus", CurrentGame.GameResult, GameStatus, CurrentGame.UniqueId);
    }

    private bool CheckForWinner()
    {
        if (CheckRowsForWinner() || CheckColumnsForWinner() || CheckDiagonalsForWinner())
        {
            return true;
        }

        // Check for a tie
        if (board.All(cell => cell != BoardElements.Empty))
        {
            GameStatus = "It's a tie!";
            return true;
        }

        return false;
    }
    private bool CheckRowsForWinner()
    {

        for (int row = TicTacToeRules.FIRST_ROW_OF_BOARD; row < TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS; row++)
        {
            if (AreAllEqual(board[row * TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS],
                board[row * TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS + 1], board[row * TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS + 2]))
            {
                GameStatus = $"{board[row * TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS]} wins!";
                return true;
            }
        }

        return false;
    }

    private bool CheckColumnsForWinner()
    {
        for (int col = TicTacToeRules.FIRST_ROW_OF_BOARD; col < TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS; col++)
        {
            if (AreAllEqual(board[col], board[col + TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS],
                board[col + 2 * TicTacToeRules.MAX_COUNT_OF_BOARD_ROWS]))
            {
                GameStatus = $"{board[col]} wins!";
                return true;
            }
        }

        return false;
    }
    private bool CheckDiagonalsForWinner()
    {
        if (AreAllEqual(board[TicTacToeRules.FIRST_ELEMENT_OF_DIAGONAL],
            board[TicTacToeRules.SECOND_ELEMENT_OF_DIAGONAL], board[TicTacToeRules.THIRD_ELEMENT_OF_DIAGONAL]))
        {
            GameStatus = $"{board[TicTacToeRules.FIRST_ELEMENT_OF_DIAGONAL]} wins!";
            return true;
        }

        if (AreAllEqual(board[TicTacToeRules.FIRST_ELEMENT_OF_REVERSE_DIAGONAL],
            board[TicTacToeRules.SECOND_ELEMENT_OF_REVERSE_DIAGONAL], board[TicTacToeRules.THIRD_ELEMENT_OF_REVERSE_DIAGONAL]))
        {
            GameStatus = $"{board[TicTacToeRules.FIRST_ELEMENT_OF_REVERSE_DIAGONAL]} wins!";
            return true;
        }

        return false;
    }
    private bool AreAllEqual(BoardElements a, BoardElements b, BoardElements c)
    {
        return a != BoardElements.Empty && a == b && b == c;
    }


    private string GetSquareValue(int index)
    {
        return (board[index] == BoardElements.Empty) ? "" : board[index].ToString();
    }

    private bool IsButtonDisabled(int index)
    {
        return CurrentGame.GameResult == GameState.Finished;
    }

    public void Dispose()
    {
        hubConnection?.DisposeAsync();
    }
}